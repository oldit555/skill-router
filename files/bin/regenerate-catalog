#!/bin/bash
# regenerate-catalog - Builds skill-catalog.yaml from plugin files
# Scans both skills/ and agents/ directories in plugins
# Compatible with bash 3.2 (no associative arrays)

set -euo pipefail

CLAUDE_DIR="$HOME/.claude"
PLUGINS_DIR="$CLAUDE_DIR/plugins"
CATALOG="$CLAUDE_DIR/skill-catalog.yaml"

# Temp directories for deduplication
TEMP_DIR=$(mktemp -d)
SKILLS_DIR="$TEMP_DIR/skills"
AGENTS_DIR="$TEMP_DIR/agents"
mkdir -p "$SKILLS_DIR" "$AGENTS_DIR"
trap "rm -rf $TEMP_DIR" EXIT

echo "Regenerating skill catalog..."

# ─────────────────────────────────────────────────────────────
# FILES TO SKIP (not real skills/agents)
# ─────────────────────────────────────────────────────────────

should_skip() {
  local name="$1"

  # Skip names starting with [ (placeholders)
  [[ "$name" == \[* ]] && return 0

  case "$name" in
    README|CHANGELOG|CREATION-LOG|EXAMPLES|COMMANDLINE-USAGE|MCP-TOOLS)
      return 0 ;;
    test-pressure|test-academic|CLAUDE_MD_TESTING|example-settings|example-skill)
      return 0 ;;
    real-world-examples|parsing-techniques|component-patterns|manifest-reference)
      return 0 ;;
    patterns|migration|advanced|effort|prompt-snippets|authentication)
      return 0 ;;
    server-types|system-prompt-design|triggering-examples)
      return 0 ;;
    *)
      return 1 ;;
  esac
}

# ─────────────────────────────────────────────────────────────
# SOURCE PRIORITY (prefer superpowers, then workflows)
# ─────────────────────────────────────────────────────────────

get_source_priority() {
  local source="$1"
  case "$source" in
    superpowers-marketplace) echo 1 ;;
    claude-code-workflows) echo 2 ;;
    anthropic-official) echo 3 ;;
    *) echo 9 ;;
  esac
}

# ─────────────────────────────────────────────────────────────
# ENCODE NAME FOR SAFE FILENAME
# ─────────────────────────────────────────────────────────────

encode_name() {
  echo "$1" | sed 's/[^a-zA-Z0-9_-]/_/g'
}

# ─────────────────────────────────────────────────────────────
# COLLECT ITEMS (skills or agents)
# $1 = path pattern (*/skills/* or */agents/*)
# $2 = output directory
# ─────────────────────────────────────────────────────────────

collect_items() {
  local path_pattern="$1"
  local output_dir="$2"
  local count=0
  local skipped=0

  while IFS= read -r file; do
    # Extract name from frontmatter or filename
    item_name=$(basename "$file" .md)

    # Try to get name from frontmatter
    if grep -q "^name:" "$file" 2>/dev/null; then
      frontmatter_name=$(grep "^name:" "$file" | head -1 | sed 's/^name:[[:space:]]*//')
      [[ -n "$frontmatter_name" ]] && item_name="$frontmatter_name"
    fi

    # Skip if in skip list
    if should_skip "$item_name"; then
      skipped=$((skipped + 1))
      continue
    fi

    # Extract description
    description=""
    if grep -q "^description:" "$file" 2>/dev/null; then
      description=$(grep "^description:" "$file" | head -1 | sed 's/^description:[[:space:]]*//' | sed 's/^"//' | sed 's/"$//')
    fi

    # Skip if no meaningful description
    if [[ -z "$description" || "$description" == '""' || ${#description} -lt 20 ]]; then
      skipped=$((skipped + 1))
      continue
    fi

    # Detect source plugin
    source_plugin="unknown"
    if echo "$file" | grep -q "plugins/cache/"; then
      source_plugin=$(echo "$file" | sed 's|.*/plugins/cache/\([^/]*\)/.*|\1|')
    elif echo "$file" | grep -q "plugins/marketplaces/"; then
      source_plugin=$(echo "$file" | sed 's|.*/plugins/marketplaces/\([^/]*\)/.*|\1|')
    fi

    # Safe filename
    safe_name=$(encode_name "$item_name")
    item_file_path="$output_dir/$safe_name"

    # Get priority of new source
    new_priority=$(get_source_priority "$source_plugin")

    # Handle duplicates - keep the one from higher priority source
    if [[ -f "$item_file_path" ]]; then
      existing_priority=$(head -1 "$item_file_path")
      if [[ $existing_priority -le $new_priority ]]; then
        continue
      fi
    fi

    # Store data in temp file
    cat > "$item_file_path" << ITEMDATA
$new_priority
$item_name
$source_plugin
$description
ITEMDATA

    count=$((count + 1))

  done < <(find "$PLUGINS_DIR" -name "*.md" -path "$path_pattern" 2>/dev/null)

  echo "$count $skipped"
}

# ─────────────────────────────────────────────────────────────
# COLLECT SKILLS AND AGENTS
# ─────────────────────────────────────────────────────────────

echo "Scanning skills..."
skill_result=$(collect_items "*/skills/*" "$SKILLS_DIR")
skill_count=$(echo "$skill_result" | cut -d' ' -f1)
skill_skipped=$(echo "$skill_result" | cut -d' ' -f2)

echo "Scanning agents..."
agent_result=$(collect_items "*/agents/*" "$AGENTS_DIR")
agent_count=$(echo "$agent_result" | cut -d' ' -f1)
agent_skipped=$(echo "$agent_result" | cut -d' ' -f2)

# ─────────────────────────────────────────────────────────────
# GENERATE CATALOG
# ─────────────────────────────────────────────────────────────

cat > "$CATALOG" << 'HEADER'
# Skill Catalog - Haiku reads this for semantic matching
# Regenerate with: regenerate-catalog or claude-update-plugins
# Auto-generated from plugin skills/ and agents/ directories

HEADER

echo "generated: $(date +%Y-%m-%dT%H:%M:%S%z)" >> "$CATALOG"

# Count unique items
unique_skills=$(ls -1 "$SKILLS_DIR" 2>/dev/null | wc -l | tr -d ' ')
unique_agents=$(ls -1 "$AGENTS_DIR" 2>/dev/null | wc -l | tr -d ' ')

echo "skill_count: $unique_skills" >> "$CATALOG"
echo "agent_count: $unique_agents" >> "$CATALOG"
echo "" >> "$CATALOG"

# Output skills (with full invocation name)
echo "skills:" >> "$CATALOG"
for item_file in $(ls -1 "$SKILLS_DIR" 2>/dev/null | sort); do
  full_path="$SKILLS_DIR/$item_file"
  item_name=$(sed -n '2p' "$full_path")
  source=$(sed -n '3p' "$full_path")
  desc=$(sed -n '4p' "$full_path")

  # Full invocation name: source:item_name
  full_name="$source:$item_name"

  echo "  $full_name:" >> "$CATALOG"
  echo "    short_name: $item_name" >> "$CATALOG"
  echo "    description: \"$desc\"" >> "$CATALOG"
  echo "" >> "$CATALOG"
done

# Output agents (with full invocation name)
echo "agents:" >> "$CATALOG"
for item_file in $(ls -1 "$AGENTS_DIR" 2>/dev/null | sort); do
  full_path="$AGENTS_DIR/$item_file"
  item_name=$(sed -n '2p' "$full_path")
  source=$(sed -n '3p' "$full_path")
  desc=$(sed -n '4p' "$full_path")

  # Full invocation name: source:item_name
  full_name="$source:$item_name"

  echo "  $full_name:" >> "$CATALOG"
  echo "    short_name: $item_name" >> "$CATALOG"
  echo "    description: \"$desc\"" >> "$CATALOG"
  echo "" >> "$CATALOG"
done

# ─────────────────────────────────────────────────────────────
# SUMMARY
# ─────────────────────────────────────────────────────────────

echo ""
echo "Catalog generated: $CATALOG"
echo "Skills: $unique_skills (skipped: $skill_skipped)"
echo "Agents: $unique_agents (skipped: $agent_skipped)"
echo ""
